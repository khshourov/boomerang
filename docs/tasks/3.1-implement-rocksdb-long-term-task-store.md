# Task 3.1: RocksDB Long-term Task Store

Implement the persistent `LongTermTaskStore` using RocksDB. This store handles tasks that are scheduled beyond the imminent in-memory window.

## Sub-tasks
1. [x] **Update Configuration:**
   - Add `rocksdb.path` and `rocksdb.enabled` to `ServerConfig.java` and `boomerang-server.properties`.
2. [x] **Implement Serialization:**
   - Add a utility or methods to serialize/deserialize `TimerTask` to/from byte arrays (excluding the non-persistent `Runnable`).
3. [x] **RocksDB Infrastructure:**
   - Create `RocksDBLongTermTaskStore.java` implementing `LongTermTaskStore`.
   - Implement lifecycle management (initialization of Column Families, closing the database).
4. [x] **Store Operations:**
   - `save(TimerTask)`: Atomically update `time_index` and `id_index` Column Families.
   - `fetchTasksDueBefore(long timestamp)`: Use a RocksDB iterator on the `time_index` CF to find and remove tasks due.
   - `findById(String taskId)`: Lookup in `id_index` to find expiration, then fetch from `time_index`.
   - `delete(TimerTask)`: Atomically remove from both Column Families.
5. [x] **Testing:**
   - Create `RocksDBLongTermTaskStoreTest.java`.
   - Ensure high test coverage and reliability.
6. [x] **Integration:**
   - Ensure `TimerFactory` or server initialization can use the new RocksDB store.

## Technical Details
- **RocksDB Path:** Default to `data/rocksdb`.
- **Column Families:**
  - `time_index`: Key is `expirationMs` (8-byte big-endian) + `taskId`. Value is serialized task data.
  - `id_index`: Key is `taskId`. Value is `expirationMs` (8-byte big-endian).
- **Serialization:** Use a simple binary format (e.g., `DataOutputStream` / `DataInputStream`) or Protobuf if preferred. Given the current structure, a custom binary format is efficient.
- **Task Reconstruction:** Use a placeholder `Runnable` (e.g., `() -> {}`) for reloaded tasks.
