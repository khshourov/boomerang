# Task Review: 2.2-tiered-scheduling-logic

## Summary
The implementation of the `TieredTimer` and `LongTermTaskStore` successfully introduces the tiered scheduling architecture as defined in `docs/SPEC.md`. It provides a clean separation between imminent in-memory tasks and long-term persistent (stubbed) tasks.

## Status: Approved with Minor Suggestions

## Strengths
- **Reactive Loading:** The use of an internal recurring `TimerTask` within the HTW to trigger the loading of long-term tasks is an elegant and efficient design. It avoids the need for additional background threads and leverages the existing timing infrastructure.
- **Durability-First:** Tasks are saved to the `LongTermTaskStore` *before* being added to the `HierarchicalTimingWheel`. This ensures that even if the system crashes immediately after registration, the task is persisted.
- **Comprehensive Testing:** The unit tests for `TieredTimer` cover routing, transition logic, and lifecycle management with 100% coverage.
- **Clean Interfaces:** The `LongTermTaskStore` interface is simple and well-defined, paving the way for the RocksDB implementation in Phase 3.

## Improvements & Observations
### 1. Initial Load on Startup (Critical for Recovery)
**Observation:** The `TieredTimer` constructor schedules the first reactive load for `loadThresholdMs` (e.g., 15 minutes) into the future.
**Risk:** If the server restarts, tasks due within the first 15 minutes will not be loaded into the HTW until the first reactive load fires, potentially causing delays.
**Suggestion:** Call `reactiveLoad()` once in the constructor (after initializing `imminentTimer`) to ensure that any tasks already due in the imminent window are loaded immediately upon startup.

### 2. Configuration Alignment
**Observation:** `ServerConfig` was updated with `timer.tick.ms` and `timer.wheel.size`, but `imminentWindowMs` is still passed as a manual parameter to the factory and constructor.
**Suggestion:** Add a `timer.imminent.window.ms` property to `ServerConfig` and `boomerang-server.properties` to keep the tiered timer configuration consistent with other components.

### 3. "Fetch-and-Delete" Pattern in Store
**Observation:** `InMemoryLongTermTaskStore.fetchTasksDueBefore` clears the submap, effectively deleting tasks as they are fetched for transition.
**Observation:** `TieredTimer.handleExpiredTask` also calls `longTermStore.delete(task)`.
**Analysis:** In the current in-memory stub, the second delete is a no-op. For the future RocksDB implementation, we should decide if a task is "moved" (deleted from long-term store and moved to a separate imminent store) or simply "marked" as transitioned. Keeping them in the long-term store until execution (the current `handleExpiredTask` logic) is safer for durability but requires `fetchTasksDueBefore` to handle windowing correctly to avoid double-loading.

## Conclusion
The implementation is technically sound and follows the project's architectural guidelines. Addressing the initial load issue will make the recovery logic more robust.

---
*Reviewer: Gemini CLI*
*Date: February 20, 2026*
