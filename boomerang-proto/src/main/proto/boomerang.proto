syntax = "proto3";

package boomerang;

option java_package = "io.boomerang.proto";
option java_multiple_files = true;

// Envelope for all communication over raw TCP.
// All requests after AuthHandshake MUST include a session_id.
message BoomerangEnvelope {
    string session_id = 1;            // Unique identifier for the client's session
    oneof payload {
        AuthHandshake auth_handshake = 2;
        AuthResponse auth_response = 3;
        Task registration_request = 4;
        RegistrationResponse registration_response = 5;
        CancellationRequest cancellation_request = 6;
        CancellationResponse cancellation_response = 7;
        SessionRefreshRequest session_refresh = 8;
        SessionRefreshResponse session_refresh_response = 9;
        ClientRegistrationRequest client_registration = 10;
        ClientRegistrationResponse client_registration_response = 11;
        ClientDeregistrationRequest client_deregistration = 12;
        ClientDeregistrationResponse client_deregistration_response = 13;
        CallbackRequest callback_request = 14;
        CallbackResponse callback_response = 15;
        ListTasksRequest list_tasks_request = 16;
        ListTasksResponse list_tasks_response = 17;
        GetTaskRequest get_task_request = 18;
        GetTaskResponse get_task_response = 19;
    }
}

// Handshake establishes the session and its configuration.
// ... (rest of the file remains same, adding new messages at the end)

message ListTasksRequest {
    string client_id = 1;             // Filter by client; Admin can see all, Clients only their own
    uint64 scheduled_after = 2;       // Start of interval (Unix epoch ms)
    uint64 scheduled_before = 3;      // End of interval (Unix epoch ms)
    optional bool is_recurring = 4;   // Filter by one-shot vs recurring
    uint32 limit = 5;                 // Max tasks to return
    string next_token = 6;            // For pagination, opaque cursor from previous response
}

message ListTasksResponse {
    Status status = 1;
    string error_message = 2;
    repeated TaskDetails tasks = 3;
    string next_token = 4;            // Opaque cursor for next page
}

message GetTaskRequest {
    string task_id = 1;
}

message GetTaskResponse {
    Status status = 1;
    string error_message = 2;
    TaskDetails task = 3;
}

message TaskDetails {
    string task_id = 1;
    string client_id = 2;
    uint64 expiration_ms = 3;
    uint64 repeat_interval_ms = 4;
    bytes payload = 5;
}
// Used for the initial authentication and to negotiate session-wide policies.
message AuthHandshake {
    string client_id = 1;             // The unique identifier for the client
    string password = 2;              // The plain-text password for authentication
}

// Client registration adds a new client with their default policies.
// Usually performed by an admin.
message ClientRegistrationRequest {
    string client_id = 1;
    string password = 2;
    bool is_admin = 3;
    CallbackConfig callback = 4;
    RetryPolicy retry = 5;
    DLQPolicy dlq = 6;
}

message ClientRegistrationResponse {
    Status status = 1;
    string error_message = 2;
}

message ClientDeregistrationRequest {
    string client_id = 1;
}

message ClientDeregistrationResponse {
    Status status = 1;
    string error_message = 2;
}

// Response to an AuthHandshake request.
message AuthResponse {
    string session_id = 1;            // The server-assigned session UUID if successful
    Status status = 2;                // The status of the authentication attempt
    string error_message = 3;         // Descriptive error if status is not OK
    uint64 expires_at_ms = 4;         // Expiry time in milliseconds (Unix epoch)
}

// Represents a task to be scheduled for future execution.
message Task {
    bytes payload = 1;                // Opaque data to be delivered to the callback endpoint
    uint64 delay_ms = 2;              // Relative delay from registration in milliseconds
    uint64 repeat_interval_ms = 3;    // 0 means no repetition, otherwise the interval for repeated execution
}

message CallbackConfig {
    enum Protocol {
        TCP = 0;
        GRPC = 1;
        HTTP = 2;
        UDP = 3;
    }
    Protocol protocol = 1;
    string endpoint = 2;
}

message RetryPolicy {
    enum BackoffStrategy {
        FIXED = 0;
        EXPONENTIAL = 1;
    }
    uint32 max_attempts = 1;
    BackoffStrategy strategy = 2;
    uint64 interval_ms = 3;           // Fixed interval OR initial exponential interval
    uint64 max_interval_ms = 4;       // Maximum interval cap for exponential backoff
}

message DLQPolicy {
    string destination = 1;           // Target identifier/endpoint for tasks that exceed max retries
}

message RegistrationResponse {
    string task_id = 1;               // Server-generated UUID
    Status status = 2;
    uint64 scheduled_time_ms = 3;     // Absolute epoch for the first execution
    string error_message = 4;
}

message CancellationRequest {
    string task_id = 1;
}

message CancellationResponse {
    Status status = 1;
    string error_message = 2;
}

message SessionRefreshRequest {}

message SessionRefreshResponse {
    Status status = 1;
    uint64 new_expires_at_ms = 2;
}

// Service implemented by clients to receive callbacks via gRPC.
service BoomerangCallback {
    // Fired when a task expires and needs to be delivered to the client.
    rpc OnTaskExpired(CallbackRequest) returns (CallbackResponse);
}

// Request sent to the client's gRPC endpoint when a task expires.
message CallbackRequest {
    string task_id = 1;               // The unique identifier for the expired task
    bytes payload = 2;                // The original binary payload registered with the task
}

// Response from the client acknowledging receipt of the callback.
message CallbackResponse {
    Status status = 1;                // Acknowledgement status
    string error_message = 2;         // Descriptive error if status is not OK
}

enum Status {
    OK = 0;
    ERROR = 1;
    UNAUTHORIZED = 2;
    INVALID_REQUEST = 3;
    SESSION_EXPIRED = 4;
}
